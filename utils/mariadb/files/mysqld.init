#!/bin/sh /etc/rc.common
# Copyright (C) 2010-2018 OpenWrt.org

# shellcheck disable=SC2034
START=95
# shellcheck disable=SC2034
STOP=10

NAME=mysqld

LOGGER="/usr/bin/logger -p user.err -s -t $NAME --"
[ -x "$LOGGER" ] || LOGGER="echo"

MYSQLD="/usr/bin/$NAME"
MYSQLDSAFE="/usr/bin/mysqld_safe"

pidfile=""

# mysqladmin likes to read /root/.my.cnf which could cause issues.
export HOME="/etc/mysql"

# Safeguard (relative paths, core dumps...)
cd /

mysqld_get_param() {
	"$MYSQLD" --help --verbose | sed -n 's|^'"$1"'[[:blank:]]\+||p'
}

# Send kill signal to MariaDB process
#
# Usage: boolean mysqld_kill signal
mysql_kill() {
	[ -n "$pidfile" ] || pidfile="$(mysqld_get_param pid-file)"
	[ -f "$pidfile" ] || return 1
	pid="$(cat $pidfile)"
	[ -n "$pid" ] || return 2
	kill "$1" "$pid"
}

# Checks if a server is running and accessible.
#
# Supported modes are 'check_alive' and 'check_dead'.
# Both check for pidfile and whether the specified process is running and is
# indeed mysqld. We could use mysqladmin for the check, but to be able to do
# so, mysqladmin requires access to the database, which sounds like overkill
# and potential security issue.
#
# Usage: boolean mysqld_status [check_alive|check_dead]
mysqld_status() {
	ps_alive=0
	pidfile="$(mysqld_get_param pid-file)"
	if [ -f "$pidfile" ] && mysql_kill -0 2> /dev/null && \
	   [ "$(readlink "/proc/$(cat "$pidfile")/exe")" = "$MYSQLD" ]; then
		ps_alive=1
	fi

	if { [ "$1" = check_alive ] && [ $ps_alive = 1 ]; } || \
		{ [ "$1" = check_dead ] && [ $ps_alive = 0 ]; }
	then
		return 0 # EXIT_SUCCESS
	else
		return 1 # EXIT_FAILURE
	fi
}

start() {
	conf=/etc/mysql/my.cnf
	logdir=/var/log/mysql
	rundir=/var/run/mysqld

	hint="please fix your server configuration in /etc/mysql/"
 
	for i in "$MYSQLD" "$MYSQLDSAFE"; do
		if [ ! -x "$i" ]; then
			$LOGGER "$i is missing"
			exit 1
		fi
	done

	if [ ! -r "$conf" ]; then
		$LOGGER "$conf cannot be read"
		exit 1
	fi

	config_load "$NAME"

	config_get_bool enabled general enabled 0
	# shellcheck disable=SC2154
	if [ "$enabled" -eq 0 ]; then
		$LOGGER "service not enabled in /etc/config/$NAME"
		exit 1
	fi

	config_get options general options

	datadir="$(mysqld_get_param datadir)"
	tmpdir="$(mysqld_get_param tmpdir)"

	if [ -z "$datadir" ]; then
		$LOGGER "datadir is not set"
		$LOGGER "$hint"
		exit 1
	fi

	if [ -z "$tmpdir" ]; then
		$LOGGER "tmpdir is not set"
		$LOGGER "$hint"
		exit 1
	fi

	if [ ! -f "$datadir/mysql/tables_priv.MAD" ]; then
		args="--force"
		basedir="$(mysqld_get_param basedir)"
		[ -n "$basedir" ] && args="$args --basedir=$basedir"

		$LOGGER "Cannot detect privileges table. You might need to run"
		$LOGGER "'mysql_install_db \"$args\"'"
		$LOGGER "to initialize the system tables."
		exit 1
	fi

	# Start daemon
	if mysqld_status check_alive; then
		$LOGGER "server is already running"
	else
		for i in "$logdir" "$rundir"; do
			opts="-m 0750"
			if ! [ -e "$i" ]; then
				# $rundir needs to be accessible for
				# clients
				if [ "$i" = "$rundir" ]; then
					opts=
				fi
				# shellcheck disable=SC2086
				mkdir -p $opts "$i"
				[ -d "$i" ] && chown mariadb:mariadb "$i"
			fi
		done
		# shellcheck disable=SC2154,SC2086
		"$MYSQLDSAFE" $options >/dev/null 2>&1 &
	fi
}

stop() {
	timeout="0"
	while mysqld_status check_alive && [ "$timeout" -lt 60 ]; do
		mysql_kill -TERM
		sleep 1
		timeout="$(($timeout + 1))"
	done
	if ! mysqld_status check_dead; then
		$LOGGER "server is failing to stop"
		mysql_kill -KILL
	fi
}

reload() {
	if mysqld_status check_alive; then
		mysql_kill -HUP
	else
		$LOGGER "server is not running"
	fi
}
