From 27b2c5ead5cf85626d4169ab46b3246d65033b58 Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Thu, 1 Mar 2018 16:31:34 +0100
Subject: [PATCH] CLEANUP: h2: rename misleading h2c_stream_close() to
 h2s_close()

This function takes an h2c and an h2s but it never uses the h2c, which
is a bit confusing at some places in the code. Let's make it clear that
it only operates on the h2s instead by renaming it and removing the
unused h2c argument.

(cherry picked from commit 00dd07895a6ee856c811c6d60a8e3d4c7d973c63)
Signed-off-by: Willy Tarreau <w@1wt.eu>
---
 src/mux_h2.c |   37 ++++++++++++++++++-------------------
 1 file changed, 18 insertions(+), 19 deletions(-)

diff --git a/src/mux_h2.c b/src/mux_h2.c
index bb0a3e3..0bb79a4 100644
--- a/src/mux_h2.c
+++ b/src/mux_h2.c
@@ -630,12 +630,11 @@ static inline __maybe_unused int h2_get_frame_hdr(struct buffer *b, struct h2_fh
 	return ret;
 }
 
-/* marks stream <h2s> as CLOSED for connection <h2c> and decrement the number
- * of active streams for this connection if the stream was not yet closed.
- * Please use this exclusively before closing a stream to ensure stream count
- * is well maintained.
+/* marks stream <h2s> as CLOSED and decrement the number of active streams for
+ * its connection if the stream was not yet closed. Please use this exclusively
+ * before closing a stream to ensure stream count is well maintained.
  */
-static inline void h2c_stream_close(struct h2c *h2c, struct h2s *h2s)
+static inline void h2s_close(struct h2s *h2s)
 {
 	if (h2s->st != H2_SS_CLOSED)
 		h2s->h2c->nb_streams--;
@@ -924,7 +923,7 @@ static int h2s_send_rst_stream(struct h2c *h2c, struct h2s *h2s)
 
  ignore:
 	h2s->flags |= H2_SF_RST_SENT;
-	h2c_stream_close(h2c, h2s);
+	h2s_close(h2s);
 	return ret;
 }
 
@@ -988,7 +987,7 @@ static int h2c_send_rst_stream(struct h2c *h2c, struct h2s *h2s)
  ignore:
 	if (h2s->st > H2_SS_IDLE && h2s->st < H2_SS_CLOSED) {
 		h2s->flags |= H2_SF_RST_SENT;
-		h2c_stream_close(h2c, h2s);
+		h2s_close(h2s);
 	}
 
 	return ret;
@@ -1066,7 +1065,7 @@ static void h2_wake_some_streams(struct h2c *h2c, int last, uint32_t flags)
 
 		if (!h2s->cs) {
 			/* this stream was already orphaned */
-			h2c_stream_close(h2c, h2s);
+			h2s_close(h2s);
 			eb32_delete(&h2s->by_id);
 			pool_free(pool_head_h2s, h2s);
 			continue;
@@ -1084,7 +1083,7 @@ static void h2_wake_some_streams(struct h2c *h2c, int last, uint32_t flags)
 		else if (flags & CS_FL_EOS && h2s->st == H2_SS_OPEN)
 			h2s->st = H2_SS_HREM;
 		else if (flags & CS_FL_EOS && h2s->st == H2_SS_HLOC)
-			h2c_stream_close(h2c, h2s);
+			h2s_close(h2s);
 	}
 }
 
@@ -1551,7 +1550,7 @@ static int h2c_handle_rst_stream(struct h2c *h2c, struct h2s *h2s)
 		return 1;
 
 	h2s->errcode = h2_get_n32(h2c->dbuf, 0);
-	h2c_stream_close(h2c, h2s);
+	h2s_close(h2s);
 
 	if (h2s->cs) {
 		h2s->cs->flags |= CS_FL_EOS | CS_FL_ERROR;
@@ -2099,7 +2098,7 @@ static int h2_process_mux(struct h2c *h2c)
 					h2s->cs->flags &= ~CS_FL_DATA_WR_ENA;
 				else {
 					/* just sent the last frame for this orphaned stream */
-					h2c_stream_close(h2c, h2s);
+					h2s_close(h2s);
 					eb32_delete(&h2s->by_id);
 					pool_free(pool_head_h2s, h2s);
 				}
@@ -2142,7 +2141,7 @@ static int h2_process_mux(struct h2c *h2c)
 				h2s->cs->flags &= ~CS_FL_DATA_WR_ENA;
 			else {
 				/* just sent the last frame for this orphaned stream */
-				h2c_stream_close(h2c, h2s);
+				h2s_close(h2s);
 				eb32_delete(&h2s->by_id);
 				pool_free(pool_head_h2s, h2s);
 			}
@@ -2501,7 +2500,7 @@ static void h2_detach(struct conn_stream *cs)
 
 	if (h2s->by_id.node.leaf_p) {
 		/* h2s still attached to the h2c */
-		h2c_stream_close(h2c, h2s);
+		h2s_close(h2s);
 		eb32_delete(&h2s->by_id);
 
 		/* We don't want to close right now unless we're removing the
@@ -2557,7 +2556,7 @@ static void h2_shutr(struct conn_stream *cs, enum cs_shr_mode mode)
 	if (h2s->h2c->mbuf->o && !(cs->conn->flags & CO_FL_XPRT_WR_ENA))
 		conn_xprt_want_send(cs->conn);
 
-	h2c_stream_close(h2s->h2c, h2s);
+	h2s_close(h2s);
 }
 
 static void h2_shutw(struct conn_stream *cs, enum cs_shw_mode mode)
@@ -2575,7 +2574,7 @@ static void h2_shutw(struct conn_stream *cs, enum cs_shw_mode mode)
 			return;
 
 		if (h2s->st == H2_SS_HREM)
-			h2c_stream_close(h2s->h2c, h2s);
+			h2s_close(h2s);
 		else
 			h2s->st = H2_SS_HLOC;
 	} else {
@@ -2593,7 +2592,7 @@ static void h2_shutw(struct conn_stream *cs, enum cs_shw_mode mode)
 		    h2c_send_goaway_error(h2s->h2c, h2s) <= 0)
 			return;
 
-		h2c_stream_close(h2s->h2c, h2s);
+		h2s_close(h2s);
 	}
 
 	if (h2s->h2c->mbuf->o && !(cs->conn->flags & CO_FL_XPRT_WR_ENA))
@@ -3049,7 +3048,7 @@ static int h2s_frt_make_resp_headers(struct h2s *h2s, struct buffer *buf)
 		if (h2s->st == H2_SS_OPEN)
 			h2s->st = H2_SS_HLOC;
 		else
-			h2c_stream_close(h2c, h2s);
+			h2s_close(h2s);
 	}
 	else if (h1m->status >= 100 && h1m->status < 200) {
 		/* we'll let the caller check if it has more headers to send */
@@ -3291,7 +3290,7 @@ static int h2s_frt_make_resp_data(struct h2s *h2s, struct buffer *buf)
 		if (h2s->st == H2_SS_OPEN)
 			h2s->st = H2_SS_HLOC;
 		else
-			h2c_stream_close(h2c, h2s);
+			h2s_close(h2s);
 
 		if (!(h1m->flags & H1_MF_CHNK)) {
 			// trim any possibly pending data (eg: inconsistent content-length)
@@ -3364,7 +3363,7 @@ static int h2_snd_buf(struct conn_stream *cs, struct buffer *buf, int flags)
 	if (h2s->st == H2_SS_ERROR || h2s->flags & H2_SF_RST_RCVD) {
 		cs->flags |= CS_FL_ERROR;
 		if (h2s_send_rst_stream(h2s->h2c, h2s) > 0)
-			h2c_stream_close(h2s->h2c, h2s);
+			h2s_close(h2s);
 	}
 
 	if (h2s->flags & H2_SF_BLK_SFCTL) {
-- 
1.7.10.4

