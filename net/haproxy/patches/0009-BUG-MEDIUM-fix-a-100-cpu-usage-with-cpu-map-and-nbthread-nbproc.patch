From 5149cd3c7abad68ddb19a0a5b3b604786d5f1b95 Mon Sep 17 00:00:00 2001
From: =?utf8?q?Cyril=20Bont=C3=A9?= <cyril.bonte@free.fr>
Date: Mon, 12 Mar 2018 21:47:39 +0100
Subject: [PATCH] BUG/MEDIUM: fix a 100% cpu usage with cpu-map and
 nbthread/nbproc

Krishna Kumar reported a 100% cpu usage with a configuration using
cpu-map and a high number of threads,

Indeed, this minimal configuration to reproduce the issue :
  global
    nbthread 40
    cpu-map auto:1/1-40 0-39

  frontend test
    bind :8000

This is due to a wrong type in a shift operator (int vs unsigned long int),
causing an endless loop while applying the cpu affinity on threads. The same
issue may also occur with nbproc under FreeBSD. This commit addresses both
cases.

This patch must be backported to 1.8.

(cherry picked from commit d400ab3a369523538c426cb70e059954c76b69c3)
Signed-off-by: Willy Tarreau <w@1wt.eu>
---
 src/haproxy.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/haproxy.c b/src/haproxy.c
index 09f7b5e..7d6e019 100644
--- a/src/haproxy.c
+++ b/src/haproxy.c
@@ -2838,7 +2838,7 @@ int main(int argc, char **argv)
 			CPU_ZERO(&cpuset);
 			while ((i = ffsl(cpu_map)) > 0) {
 				CPU_SET(i - 1, &cpuset);
-				cpu_map &= ~(1 << (i - 1));
+				cpu_map &= ~(1UL << (i - 1));
 			}
 			ret = cpuset_setaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1, sizeof(cpuset), &cpuset);
 		}
@@ -3038,7 +3038,7 @@ int main(int argc, char **argv)
 
 				while ((j = ffsl(cpu_map)) > 0) {
 					CPU_SET(j - 1, &cpuset);
-					cpu_map &= ~(1 << (j - 1));
+					cpu_map &= ~(1UL << (j - 1));
 				}
 				pthread_setaffinity_np(threads[i],
 						       sizeof(cpuset), &cpuset);
-- 
1.7.10.4

