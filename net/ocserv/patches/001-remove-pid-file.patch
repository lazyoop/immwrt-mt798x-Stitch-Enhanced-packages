From 6de26b94089929e4cc57c23aa07ae78cfb6ef2a5 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos <nmav@gnutls.org>
Date: Sat, 26 Jul 2014 10:57:26 +0200
Subject: [PATCH 1/2] made macro usage safer

That solves an issue where the pid_file would be overwritten on
a configuration file reload.
---
 src/config.c          | 24 ++++++++++++------------
 src/sup-config/file.c | 20 ++++++++++----------
 2 files changed, 22 insertions(+), 22 deletions(-)

diff --git a/src/config.c b/src/config.c
index f87fcfc..bc7a0b1 100644
--- a/src/config.c
+++ b/src/config.c
@@ -158,7 +158,7 @@ unsigned j;
 	return NULL;
 }
 
-#define READ_MULTI_LINE(name, s_name, num) \
+#define READ_MULTI_LINE(name, s_name, num) { \
 	val = get_option(name, &mand); \
 	if (val != NULL && val->valType == OPARG_TYPE_STRING) { \
 		if (s_name == NULL) { \
@@ -181,9 +181,9 @@ unsigned j;
 	} else if (mand != 0) { \
 		fprintf(stderr, "Configuration option %s is mandatory.\n", name); \
 		exit(1); \
-	}
+	}}
 
-#define READ_MULTI_BRACKET_LINE(name, s_name, s_name2, num) \
+#define READ_MULTI_BRACKET_LINE(name, s_name, s_name2, num) { \
 	val = get_option(name, &mand); \
 	if (val != NULL && val->valType == OPARG_TYPE_STRING) { \
 		if (s_name == NULL || s_name2 == NULL) { \
@@ -211,25 +211,25 @@ unsigned j;
 	} else if (mand != 0) { \
 		fprintf(stderr, "Configuration option %s is mandatory.\n", name); \
 		exit(1); \
-	}
+	}}
 
-#define READ_STRING(name, s_name) \
+#define READ_STRING(name, s_name) { \
 	val = get_option(name, &mand); \
 	if (val != NULL && val->valType == OPARG_TYPE_STRING) \
 		s_name = talloc_strdup(config, val->v.strVal); \
 	else if (mand != 0) { \
 		fprintf(stderr, "Configuration option %s is mandatory.\n", name); \
 		exit(1); \
-	}
+	}}
 
-#define READ_STATIC_STRING(name, s_name) \
+#define READ_STATIC_STRING(name, s_name) { \
 	val = get_option(name, &mand); \
 	if (val != NULL && val->valType == OPARG_TYPE_STRING) \
 		snprintf(s_name, sizeof(s_name), "%s", val->v.strVal); \
 	else if (mand != 0) { \
 		fprintf(stderr, "Configuration option %s is mandatory.\n", name); \
 		exit(1); \
-	}
+	}}
 
 #define READ_TF(name, s_name, def) \
 	{ char* tmp_tf = NULL; \
@@ -244,7 +244,7 @@ unsigned j;
 		talloc_free(tmp_tf); \
 	}
 
-#define READ_NUMERIC(name, s_name) \
+#define READ_NUMERIC(name, s_name) { \
 	val = get_option(name, &mand); \
 	if (val != NULL) { \
 		if (val->valType == OPARG_TYPE_NUMERIC) \
@@ -254,9 +254,9 @@ unsigned j;
 	} else if (mand != 0) { \
 		fprintf(stderr, "Configuration option %s is mandatory.\n", name); \
 		exit(1); \
-	}
+	}}
 
-#define READ_PRIO_TOS(name, s_name) \
+#define READ_PRIO_TOS(name, s_name) { \
 	val = get_option(name, &mand); \
 	if (val != NULL) { \
 		if (val->valType == OPARG_TYPE_STRING) { \
@@ -271,7 +271,7 @@ unsigned j;
 	} else if (mand != 0) { \
 		fprintf(stderr, "Configuration option %s is mandatory.\n", name); \
 		exit(1); \
-	}
+	}}
 
 
 static int handle_option(const tOptionValue* val)
diff --git a/src/sup-config/file.c b/src/sup-config/file.c
index 20a97f2..44c4a9d 100644
--- a/src/sup-config/file.c
+++ b/src/sup-config/file.c
@@ -61,7 +61,7 @@ static struct cfg_options available_options[] = {
 	{ .name = "cgroup", .type = OPTION_STRING, },
 };
 
-#define READ_RAW_MULTI_LINE(name, s_name, num) \
+#define READ_RAW_MULTI_LINE(name, s_name, num) { \
 	val = optionGetValue(pov, name); \
 	if (val != NULL && val->valType == OPARG_TYPE_STRING) { \
 		if (s_name == NULL) { \
@@ -77,26 +77,26 @@ static struct cfg_options available_options[] = {
 		        num++; \
 	      } while((val = optionNextValue(pov, val)) != NULL); \
 	      s_name[num] = NULL; \
-	}
+	}}
 
-#define READ_RAW_STRING(name, s_name) \
+#define READ_RAW_STRING(name, s_name) { \
 	val = optionGetValue(pov, name); \
 	if (val != NULL && val->valType == OPARG_TYPE_STRING) { \
 		if (s_name != NULL) \
 			talloc_free(s_name); \
 		s_name = talloc_strdup(proc, val->v.strVal); \
-	}
+	}}
 
-#define READ_RAW_NUMERIC(name, s_name) \
+#define READ_RAW_NUMERIC(name, s_name) { \
 	val = optionGetValue(pov, name); \
 	if (val != NULL) { \
 		if (val->valType == OPARG_TYPE_NUMERIC) \
 			s_name = val->v.longVal; \
 		else if (val->valType == OPARG_TYPE_STRING) \
 			s_name = atoi(val->v.strVal); \
-	}
+	}}
 
-#define READ_RAW_PRIO_TOS(name, s_name) \
+#define READ_RAW_PRIO_TOS(name, s_name) { \
 	val = optionGetValue(pov, name); \
 	if (val != NULL) { \
 		if (val->valType == OPARG_TYPE_STRING) { \
@@ -108,9 +108,9 @@ static struct cfg_options available_options[] = {
 				s_name++; \
 			} \
 		} \
-	}
+	}}
 
-#define READ_TF(name, s_name, def) \
+#define READ_TF(name, s_name, def) { \
 	{ char* tmp_tf = NULL; \
 		READ_RAW_STRING(name, tmp_tf); \
 		if (tmp_tf == NULL) s_name = def; \
@@ -121,7 +121,7 @@ static struct cfg_options available_options[] = {
 				s_name = 0; \
 		} \
 		talloc_free(tmp_tf); \
-	}
+	}}
 
 static int handle_option(const tOptionValue* val)
 {
-- 
2.0.0

